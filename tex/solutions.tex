\newpage
\section{Аналіз існуючих рішень}
\subsection{Огляд існуючих алгоритмів}
Єдиний вибір, що повинна зробити програма, що грає в го, це куди поставити наступний камінь. Однак, цей вибір ускладнюється тим, що навіть один камінь може дуже сильно впливати на ситуацію на дошці в цілому. У той же час не можно забувати про об'єднання каменів --- їх групи, та про взаємодію цих груп між собою. Для вирішення цієї проблеми використовуються різні підходи. Розглянемо деякі з них.
\subsubsection{Мінімаксний пошук по дереву варіантів}
Мінімаксний пошук може використовуватися для того, щоб моделювати велику кількість різних партій. Загалом, алгоритм простий: спочатку алгоритм по черзі грає усі варіанти ходів до деякого моменту. Потім використовується функція оцінки позицій, для вираховування того, наскільки поточна позиція гарна для кожного гравця. Далі, на основі цього зваженого дерева ходів, робиться розрахунок оптимальної стратегії для одного з гравцій --- вибираються ті ходи, що дають найбільше переваги цьому гравцю.

Хоча цей метод був досить ефективним для шах, він не дуже підходить для го. По-перше, через те, що досі не було створено відповідної функції оцінки для позиції в го. Гра го все ще не формалізована математично, тому поточні функції оцінки партії запрограмовані робити висновки як люди. Тобто програмісти намагалися навчити свої програми грати, як вони самі. По-друге, через те, що для партії в го притаманний великий фактор розгалуження. У кожний момент гри для кожного з гравців існує дуже багато коректних ходів. Також самі партії в го довші, ніж у шахах. Саме тому такі методи дуже обчислювально коштовні. На данний момент програми, що використовують подібні алгоритми можуть грати тількі на дошках менших ніж 9x9.

Є декілька технік, що дозволяють значно спростити обчислення для цього методи. Такі методи базуються на відсіченні піддерев за деякими правилами та дозволяють значно зменшити фактор розгалуження не послаблюючи алгоритм. Також для оптимізації роботи з деревом у подібних алгоритмах доцільно використовувати хешування стану дошки. Найкращим методом хешування для го є метод Зобріст-хешування. Він базується на використанні функції XOR до поточного стану усіх клітинок на дошці. Цей метод гарно себе показав, по відношенню до го, адже він дозволяє легко рахувати хеш нового положення дошки, маючи попередній хеш та послідовність ходів, тобто дозволяє не перераховувати його з самого початку. Також існує підхід по відсіченню піддерев, використовуючи деякі припущення про саму партію. Наприклад, надавати пріорітет ходам, що намагаються врятувати групу каменів, або знижувати пріорітет на ділянках дошки, що все є досить сильними для одного з гравців. Але такі варіанти створюють небезпеку не враховування деяких вкрай важливих ходів, які б кардинально змінили течію гри, тому такі підходи є досить ризиковими.

Результати ігор між різними комп'ютерними програми, що використовують різні методи, дозволило прийти до висновку, що кращий спосіб гри в го --- поєднання методів порівняння зі зразком із методами швидкого локалізованого тактичного пошуку. Розглянемо їх у наступних розділах.
\subsubsection{Порівняння зі зразком}
Методи, що використовують порівняння зі зразком маніпулюють послідовністю ходів, що є прийнятною для обох гравців. Це відомі маленькі шматочки з яких найчастіше складаються локальні ситуації. Такі послідовності добре вивчені і обґрунтовані, тому достатньо їх правильно використовувати всередині гри. Пошук цих зразків є дуже важливим як для гравців-людей, так я для програм, що грають в го. Розглянемо один із можливих алгоритмів пошуку таких зразків в іграх го.

Виберемо деяку зону на дошці, яку будемо вважати зразком. Наприклад квадрат 5x5. Потім потрібно його захешувати, тобто представити у вигляді int64 числа. Однак перец цим потрібно привести його до деякого базового вигляду. Адже навіть однакові зразки з точністю до повороту або симетрії будуть виглядати різними на дошці, бо не будуть співпадати поклітинно. Вього вісім ``різних'' позицій будут однаковими. Чотири повороти(на 0, 90, 180, 270 градусів відповідно) і 4 повороти віддзеркаленого зразка. Нехай базовий вигляд буде вигляд, у якого хеш найменше число. Тоді порахувавши 8 хешів і обравши менший, ми зведемо всі подібні зразки до одного. Далі, якщо зберігти багато подібних зразків у базу, єю можна будет користуватися, шукаючи у ній частинки поточної гри. З великою ймовірністю, декілька початкових каменів дадуть змогу знайти відповідний гарний шаблон, який і треба будет далі відіграти програмі.

Говорячи про ймовірність, можна згадати ще один клас методів гри у го --- методи, засновані на вірогідності. Він використовує напрацювання попереднього методу, додаючи до них цікавий алгоритм навчання.
\subsubsection{Методи, засновані на вірогідності}
Базуючись на попередньому методі, можна отримати базу зразків ігор досвідчених гравців. Використовуючи цю базу, можна отримати розподіл ймовірностей ходів для професійних ігор, який можна використовувати для відтворення цих ходів у окремій програмі. Цей розподіл можна використовувати не тільки для програми, що грає в го, але й в якості навчального посібника для гравців у го. Цей метод має дві основні складові: 1) схема вилучення шаблону з експертних партій гри (реалізовано у попередньому пункті) 2) байесовський алгоритм навчання, який навчається розподілу аналізуючи ходи у локальному місці дошки.

Якщо спробувати комп'ютер мислити як людина, щоб аналізувати локальну позицію на дошці, то можна отримати методи, засновані на базі знань.
\subsubsection{Методи, засновані на базі знань}
Якщо використовувати все ті ж самі шаблони, згенеровані методом порівняння зі зразком, але додати до них інтелект програміста, то вийде досить сильна програма для гри в го. Під інтелектом програміста, мається на увазі можливість вирішувати локальну позицію у шаблоні використовуючи деякий набор еврістик. Програмісту достатньо тільки перевести ці правила в комп'ютерний код та використати пошук за зразком, щоб знаходити ситуації, де ці правила доречні. Основний недолік - складність цих правил, а точніше можливість програмування їх, залежить насамперед від здатності та навику гри в го самого програміста. Зважаючи на те, що математичного апарату для подібної роботи нема, кожен програміст намагається навчити свою програму грати, як він. Тому найчастіше програми мають більше сотні модулів, що вираховують найкращий хід кожен окремо для своєї ситуації. Однак такі методи страждають від проблем, аналогічних попереднім --- нерозуміння глобальної ситуації. Це призводить до того, що вони роблять помилки у стратегічному плані. Відомо, що можливо програти гру, якщо у вирішальний момент обрати неправильний хід.

Наступний метод вирішує проблемні питання у стратегії повним ігноруванням її, як і самих правил. Методи Монте-Карло використовуються у багатьох галузях знать, таких як математична статистика і теоретична фізика. Знайшли вони застосування і в алгоритмах для гри у го.
\subsubsection{Методи Монте-Карло}
Одією з головних альтернатив використанню жорстко запрограмованих методів пошуку --- використовувати методи Монте-Карло. Якщо говорити про го, то цей метод полягає в наступному:  згенеруємо список потенційних ходів, які ми хочемо перевірити; для кожного такого ходу зіграємо тисячу випадкових партій (тобто наступних випадкових ходів до остаточного кінця гри --- стану на дошці, при якому можливо точно визначити переможця); виберемо з списку ходів той, при якому найбільша кількість з випадкових партій виграна програмою.

Перевага цього методу полягає в тому, що він потребує дуже малих знань про предметну область, у якій працює, недоліком є те, що він використовує більше пам'яті та процесорного часу. Однак через те, що ходи генеруються випадковим чином, ми можемо неправильно оцінити якість ходу. Наприклад, якщо у відповідь на якийсь хід буде згенеровано 100 ходів-відповідей, у більшості з який перший гравець виграє, ми будемо оцінювати цей хід як дуже сильний. Однак існує можливість того, що є дуже добра відповідь на наш хід, яка зведе нашу перевагу на нівець, однак, через те, що ми не згенерували цей хід, ми про це не дізнаємося. В результаті цього, програма буде сильна в загальному стратегічному сенсі, однак буде дуже слаба тактично. Цю проблему можна вирішити, якщо додати деякі проблемно-орієнтовні знання в генерацію ходів та підвищити глибину пошуку.

У 2006 році був створений новий пошуковий алгоритм, що був використаний для гри на дошках розміру 9x9 та зарекомендував себе дуже гарно. Він називається Upper Confidence Bounds algorithm і базується на методі Монте-Карло. Алгоритм UCT змінює правила за якими визначається важливість ходів у дереві пошуку. Він вибирає те піддерево, у якому вірогідність перемоги більше 50\%. Якщо ж не існує такого піддерева, то вибір робиться навмання.
\subsection{Огляд існуючих програмних продуктів}
Кожна програма, що грає в го повинна вміти ефективно шукати ходи/партії у своїй внутрішній базі данних. Однак партії з го мають важливе навчальне значення самі по собі. Тому існують програми, що єдиною своєю метою ставлять роботу з партіями го. Вони об'єднують багато партій в одну базу даних і маніпулюють єю. Розглянемо деякі з них.
\subsubsection{Kombilo}
Kombilo --- програма, що працює з базою го ігор. Основне завдання такої програми --- пошук деяких підпослідовностей в колекції SGF-ігор (наприклад пошук усіх ігор з деяким початком). Також ця програма дозволяє шукати по деяким властивостям ігор (таким, як гравці, події, дати).

Особливості програми:
\begin{itemize}
	\item Можливість пошуку як по повному ігровому поля, так і по позиціями у куті або на стороні дошки. Пошук ведеться також враховуючи симетрію та поворот. Існує можливість інвертувати пошук по кольору гравців, тобто поміняти їх місцями.
	\item Kombilo також комплектується повним редактором SGF: тобто існує можливість редагувати файли, коментувати їх та інше. Також редактор дозволяє бачити дерево варіантів ігри. Він дозволяє повертати/віддзеркалювати ігри.
	\item Kombilo також має у собі механізм по відображенню посилань. Цей механізм додає підказки до ігор, що впізнає. На поточний момент база цих посилань налічує 2000 записів.
	\item Можливо використовувати складні запити, використовуючи напряму SQL-базу, що зберігає розпарсені ігри.
	\item Можливо застосувати будь-яку комбінацію пошукових запитів, та у будь-який момент отримати список поточних ігор.
\end{itemize}

Говорячи про реалізацію програми, можна відзначити що вона написана на Python, тому може вважатися кроссплатформеною. Основне ж ядро, що присвячене пошуку, також написане на С++. Компілюючи його у модуль та підключаючи до основної програми ми отримаємо збільшення швидкодіє більше, ніж у два рази. Також це відкрита програма, і програмний код доступний для читання та аналізу.
\subsubsection{Master Go}
Це комерційна програма, що працює з базими даних гри го і призначена для пошуку поширених початків та розвитків ігор (вивченні фусекі і дзосекі). База даних містить 53059 професійних ігор у власному форматі. Оновлення доступні для всіх зареєстрованих користувачів.  Можливо додавати ігри в базу, що постачається з MasterGo шляхом придбання цих ігор в Японії, Китаї і Кореї і копіюванням їх в базу. Також Master Go працює тільки на операційній системі MS Windows.

Якщо порівнювати цю програму з Kombilo, та можна помітити декілька речей: 1) Master Go, комерційна та платна програма 2) вона швидша, адже написана безпосередньо під одну платформу 3) вона використовує внутрішній формат даних, що також є не дуже зручним.
\subsubsection{BiGo Assistant}
BiGo Assistant --- програма для роботи з базами даних фусекі та джосекі, створена для гравців, що хочуть підняти свій рівень гри в го.

Основні особливості:
\begin{itemize}
	\item Можливість не тільки вивчати ігри го в цілому, але й переглядати ігри професіоналів у декільках режимах
	\item Можливість вивчати початковий розвиток партії в го (фусекі) за прикладом бази даних професійних ігор
	\item Також присутня база даних джосекі
	\item Можливість аналізувати власні початки різних ігри
	\item Динамічний інтерфейс --- можливість створення будь-якої кількості вікон з різними іграми
	\item Можливість роздруковувати партії
	\item Можливість застосувати до дошки всі 8 можливих перетворень (симетрія та поворот)
	\item Програма відслідковує дублікати ігор
	\item Можливість збирати статистику по списку ігор у вигляді статистики по варіаціям можливих рухів або оціночну статистику позицій у грі обох гравців
	\item Пошук по заданій позиції (по одній або декільком частинам дошки)
\end{itemize}

Програма має багато можливостей, однак через те, що цікавим представляється тільки метод пошуку, ця програма має одну важливу відмінність від усліх інших: вона дозволяє шукати по декільком частинам дошки.

Після аналізу можливостей існуючих рішень по темі дипломної роботи, можна ставити задачу по розробці власної програми, враховуючи 
\subsection{Постановка задачі}
Було вибрано реалізувати бібліотеку, яка б містила деякі з запропонованих методів пошуку, а саме:
\begin{itemize}
	\item Мінімаксний пошук по дереву
	\item Порівняння зі зразком
	\item Метод Монте-Карло
\end{itemize}
Ці методи були вибрані тому, що вони самі по собі не залежать від гри, а тількі від внутрішнього представлення цієї гри. Також цим методам, на відміну від інших, не треба ``пояснювати'' правила го, вони можут працювати окремо і бути використані у іншому модулі для аналогічного пошуку у подібних структурах даних інших ігор.

Створити бібліотеку було вибрано тому, що це гарний спосіб інкапсулювати декілька реалізацій методу пошуку у структурах даних гри го. Також у такий спосіб інші програми або модулі можуть використовувати ці реалізації, більш піклуючись про інші аспекти гри.