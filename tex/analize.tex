\newpage
\section{Аналіз існуючих рішень}
\subsection{Огляд існуючих алгоритмів}
Єдиний вибір, що повинна зробити програма, що грає в го, це куди поставити наступний камінь. Однак, цей вибір ускладнюється тим, що навіть один камінь може дуже сильно впливати на ситуацію на дошці в цілому. У той же час не можно забувати про об'єднання каменів --- їх групи, та про взаємодію цих груп між собою. Для вирішення цієї проблеми використовуються різні підходи. Розглянемо деякі з них.
\subsubsection{Мінімаксний пошук по дереву варіантів}
Мінімаксний пошук може використовуватися для того, щоб моделювати велику кількість різних партій. Загалом, алгоритм простий: спочатку алгоритм по черзі грає усі варіанти ходів до деякого моменту. Потім використовується функція оцінки позицій, для вираховування того, наскільки поточна позиція гарна для кожного гравця. Далі, на основі цього зваженого дерева ходів, робиться розрахунок оптимальної стратегії для одного з гравцій --- вибираються ті ходи, що дають найбільше переваги цьому гравцю.

Хоча цей метод був досить ефективним для шах, він не дуже підходить для го. По-перше, через те, що досі не було створено відповідної функції оцінки для позиції в го. Гра го все ще не формалізована математично, тому поточні функції оцінки партії запрограмовані робити висновки як люди. Тобто програмісти намагалися навчити свої програми грати, як вони самі. По-друге, через те, що для партії в го притаманний великий фактор розгалуження. У кожний момент гри для кожного з гравців існує дуже багато коректних ходів. Також самі партії в го довші, ніж у шахах. Саме тому такі методи дуже обчислювально коштовні. На данний момент програми, що використовують подібні алгоритми можуть грати тількі на дошках менших ніж 9x9.

Є декілька технік, що дозволяють значно спростити обчислення для цього методи. Такі методи базуються на відсіченні піддерев за деякими правилами та дозволяють значно зменшити фактор розгалуження не послаблюючи алгоритм. Також для оптимізації роботи з деревом у подібних алгоритмах доцільно використовувати хешування стану дошки. Найкращим методом хешування для го є метод Зобріст-хешування. Він базується на використанні функції XOR до поточного стану усіх клітинок на дошці. Цей метод гарно себе показав, по відношенню до го, адже він дозволяє легко рахувати хеш нового положення дошки, маючи попередній хеш та послідовність ходів, тобто дозволяє не перераховувати його з самого початку. Також існує підхід по відсіченню піддерев, використовуючи деякі припущення про саму партію. Наприклад, надавати пріорітет ходам, що намагаються врятувати групу каменів, або знижувати пріорітет на ділянках дошки, що все є досить сильними для одного з гравців. Але такі варіанти створюють небезпеку не враховування деяких вкрай важливих ходів, які б кардинально змінили течію гри, тому такі підходи є досить ризиковими.

Результати ігор між різними комп'ютерними програми, що використовують різні методи, дозволило прийти до висновку, що кращий спосіб гри в го --- поєднання методів порівняння зі зразком із методами швидкого локалізованого тактичного пошуку. Розглянемо їх у наступних розділах.
\subsubsection{Порівняння зі зразком}
Методи, що використовують порівняння зі зразком маніпулюють послідовністю ходів, що є прийнятною для обох гравців. Це відомі маленькі шматочки з яких найчастіше складаються локальні ситуації. Такі послідовності добре вивчені і обґрунтовані, тому достатньо їх правильно використовувати всередині гри. Пошук цих зразків є дуже важливим як для гравців-людей, так я для програм, що грають в го. Розглянемо один із можливих алгоритмів пошуку таких зразків в іграх го.

Виберемо деяку зону на дошці, яку будемо вважати зразком. Наприклад квадрат 5x5. Потім потрібно його захешувати, тобто представити у вигляді int64 числа. Однак перец цим потрібно привести його до деякого базового вигляду. Адже навіть однакові зразки з точністю до повороту або симетрії будуть виглядати різними на дошці, бо не будуть співпадати поклітинно. Вього вісім ``різних'' позицій будут однаковими. Чотири повороти(на 0, 90, 180, 270 градусів відповідно) і 4 повороти віддзеркаленого зразка. Нехай базовий вигляд буде вигляд, у якого хеш найменше число. Тоді порахувавши 8 хешів і обравши менший, ми зведемо всі подібні зразки до одного. Далі, якщо зберігти багато подібних зразків у базу, єю можна будет користуватися, шукаючи у ній частинки поточної гри. З великою ймовірністю, декілька початкових каменів дадуть змогу знайти відповідний гарний шаблон, який і треба будет далі відіграти програмі.

Говорячи про ймовірність, можна згадати ще один клас методів гри у го --- методи, засновані на вірогідності. Він використовує напрацювання попереднього методу, додаючи до них цікавий алгоритм навчання.
\subsubsection{Методи, засновані на вірогідності}
Базуючись на попередньому методі, можна отримати базу зразків ігор досвідчених гравців. Використовуючи цю базу, можна отримати розподіл ймовірностей ходів для професійних ігор, який можна використовувати для відтворення цих ходів у окремій програмі. Цей розподіл можна використовувати не тільки для програми, що грає в го, але й в якості навчального посібника для гравців у го. Цей метод має дві основні складові: 1) схема вилучення шаблону з експертних партій гри (реалізовано у попередньому пункті) 2) байесовський алгоритм навчання, який навчається розподілу аналізуючи ходи у локальному місці дошки.

Якщо спробувати комп'ютер мислити як людина, щоб аналізувати локальну позицію на дошці, то можна отримати методи, засновані на базі знань.
\subsubsection{Методи, засновані на базі знань}
Якщо використовувати все ті ж самі шаблони, згенеровані методом порівняння зі зразком, але додати до них інтелект програміста, то вийде досить сильна програма для гри в го. Під інтелектом програміста, мається на увазі можливість вирішувати локальну позицію у шаблоні використовуючи деякий набор еврістик. Програмісту достатньо тільки перевести ці правила в комп'ютерний код та використати пошук за зразком, щоб знаходити ситуації, де ці правила доречні. Основний недолік - складність цих правил, а точніше можливість програмування їх, залежить насамперед від здатності та навику гри в го самого програміста. Зважаючи на те, що математичного апарату для подібної роботи нема, кожен програміст намагається навчити свою програму грати, як він. Тому найчастіше програми мають більше сотні модулів, що вираховують найкращий хід кожен окремо для своєї ситуації. Однак такі методи страждають від проблем, аналогічних попереднім --- нерозуміння глобальної ситуації. Це призводить до того, що вони роблять помилки у стратегічному плані. Відомо, що можливо програти гру, якщо у вирішальний момент обрати неправильний хід.

Наступний метод вирішує проблемні питання у стратегії повним ігноруванням її, як і самих правил. Методи Монте-Карло використовуються у багатьох галузях знать, таких як математична статистика і теоретична фізика. Знайшли вони застосування і в алгоритмах для гри у го.
\subsubsection{Методи Монте-Карло}
Одією з головних альтернатив використанню жорстко запрограмованих методів пошуку --- використовувати методи Монте-Карло. Якщо говорити про го, то цей метод полягає в наступному:  згенеруємо список потенційних ходів, які ми хочемо перевірити; для кожного такого ходу зіграємо тисячу випадкових партій (тобто наступних випадкових ходів до остаточного кінця гри --- стану на дошці, при якому можливо точно визначити переможця); виберемо з списку ходів той, при якому найбільша кількість з випадкових партій виграна програмою.

Перевага цього методу полягає в тому, що він потребує дуже малих знань про предметну область, у якій працює, недоліком є те, що він використовує більше пам'яті та процесорного часу.

The advantage of this technique is that it requires very little domain knowledge or expert input, the trade-off being increased memory and processor requirements. However, because the moves used for evaluation are generated at random it is possible that a move which would be excellent except for one specific opponent response would be mistakenly evaluated as a good move. The result of this are programs which are strong in an overall strategic sense, but are weak tactically. This problem can be mitigated by adding some domain knowledge in the move generation and a greater level of search depth on top of the random evolution.

In 2006, a new search technique, upper confidence bounds applied to trees (UCT), was developed and applied to many 9x9 Monte-Carlo Go programs with excellent results. UCT uses the results of the play outs collected so far to guide the search along the more successful lines of play, while still allowing alternative lines to be explored. The UCT technique along with many other optimizations for playing on the larger 19x19 board has led MoGo to become one of the strongest research programs. Successful early applications of UCT methods to 19x19 Go include MoGo, Crazy Stone, and Mango. MoGo won the 2007 Computer Olympiad and won one (out of three) blitz game against Guo Juan, 5th Dan Pro, in the much less complex 9x9 Go. The Many Faces of Go won the 2008 Computer Olympiad after adding UCT search to its traditional knowledge-based engine.
\subsection{Огляд існуючих програмних продуктів}
Кожна програма, що грає в го повинна вміти ефективно шукати ходи/партії у своїй внутрішній базі данних. Однак партії з го мають важливе навчальне значення самі по собі. Тому існують програми, що єдиною своєю метою ставлять роботу з партіями го. Вони об'єднують багато партій в одну базу даних і маніпулюють єю. Розглянемо деякі з них.
\subsubsection{Kombilo}
Kombilo is a go database program. Its particular strength is searching for move patterns in a collection of SGF files (like searching for all games where a particular opening or a particular joseki is played). You can also search for other properties of the game (like players, events, date, ...).

\begin{itemize}
	\item You can search for full board patterns, or for patterns occurring in a corner, on the side or anywhere on the board. All patterns given by symmetries of the board are found as well, and also - unless you disable it - the pattern obtained by exchanging black and white.
	\item Kombilo comes with a complete SGF editor: so you can add variations of your own, comment the game, add labels etc. The SGF editor can also handle collections, i.e. SGF files containing several games. The tree structure of the current game is shown in a separate window. You can rotate/mirror SGF files.
	\item Kombilo has built in list of references to commentaries of games in the English go literature. (NB: Kombilo does not come with the game records, but recognizes the games by the Dyer signature.) Those games in your database which Kombilo finds in its list are marked in the game list, and in the game info a reference to the journal/book which has the commentary is given. Currently the list contains almost 2000 references, and includes references to the game commentaries in all issues of Go World, and in most English go books with game comentaries.
	\item You can search for pieces of the game information, i.e. for player names, events, date, etc., and you can issue complex queries by directly accessing the underlying SQL database.
	\item After any combination of searches, you can quickly have a date profile of the current list of games displayed.
	\item You can refine pattern searches in many ways: by fixing who should move next in the search pattern, by allowing or disabling search for the pattern with black/white exchanged, by requiring that the pattern should occur before some specified point in the game (before move 50, say), by searching for move sequences, etc. By default, this version of Kombilo also searches in variations. The pattern search has been “parallelized” and hence can use several processor cores. Depending on your hardware, this results in a significant speed-up in comparison to older Kombilo versions.
\end{itemize}
\subsubsection{Master Go}
A commercial Go database program designed for searching patterns, such as when studying Fuseki and Joseki. The database contains 53059 professional games in a proprietary format (as of April 24 2011). Updates are available to all registered users.

MasterGo stores its data in a proprietary format. One can add games to the set shipped with MasterGo. The MasterGo game database is compiled by purchasing Go books in Japan, China and Korea; copying game records from those books into the MasterGo game database. The makers of MasterGo regard this as a legitimate activity. (See kifu copyright discussion.) However, extracting games from the is regarded by the makers of MasterGo as a copyright violation. This is interesting. Copying by computer (from MasterGo or GoGoD) is regarded as a copyright violation. Velobici - edit Charles Matthews
\subsubsection{GoBase}
Welcome to GoBase.org, which was established as Go, An Addictive Game in October 1994 (a brief historical overview is available). On these pages you'll find a lot of information on the game of Go (Go is the western word for the game, in China the game is called wei ch'i, in Korea baduk). Of course, the Go rules are explained (in 8 languages), but you can also read about the history of Go, read stories and anecdotes related to Go, study the indepth study material, study baduk academy material in the problem section, connect to one of the online Go servers (reference: IGS clients) or retrieve information on Go and computers. You're really advised to browse around and see which topics are of special interest to you. 

The repository is your personal use of GoBase, the Go database program. You can create your own collection of games and analyse these games by executing GoBase searches on the main database of 48787 professional go games, 48665560 positions (as of June 2014). The games and GoBase search results will be saved for you and will only be accessible by you. A tutorial is available for the impatient.

шо зовсем нема помілок?

Selecting the replay icon from the game listing will start up the online replay board. Do this now with one of the games you uploaded. If necessary create an SGF file with a few moves using one of the many freely available SGF editors.

We will define a pattern and use GoBase to search for all games which contain the selected pattern. Move to the moment in the game which contains the position which you would like to search. Now you have to indicate the part of the board relevant for the search. This selection is done using the (sensitive) border just outside the board. This border is also used to display the board coordinates in case you have these turned on. You select one point on a vertical axis and one on a horizontal axis. These two points define one of the corners of a rectangle. The other is implicitly defined by them.
\subsection{Постановка задачі}
Було вибрано реалізувати бібліотеку для мови Clojure, яка б містила деякі з запропонованих методів пошуку, а саме:
\begin{itemize}
	\item Мінімаксний пошук по дереву
	\item Порівняння зі зразком
	\item Метод Монте-Карло
\end{itemize}
Ці методи були вибрані тому, що вони самі по собі не залежать від гри, а тількі від внутрішнього представлення цієї гри.  Також цим методам, на відміну від інших, не треба ``пояснювати'' правила го, вони можут працювати окремо і бути використані у іншому модулі для аналогічного пошуку у подібних структурах даних інших ігор.