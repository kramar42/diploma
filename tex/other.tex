\newpage
\subsection{Перешкоди для високоефективного компьютерного Го}
Протягом довгого часу було широко поширена думка, що комп'ютерне Го являє собою проблему, що в корені відрізняється від комп'ютерних шахів, оскільки вважалося, що методи, що спираються на швидкий глобальний пошук дадуть гірший результат, порівняно з експертою оцінкою гри.
Саме тому більша частина зусиль в області розвитку комп'ютерних програм того часу була зосереджена на експертних системах. Були спроби об'єднати такі системи з локальним покушом, аби дати можливість програмі відповідати на питання тактичного характеру.
Результатом цього були створені програми, які мали здатність обробляюти багато різних локальних ситуацій, але які мали дуже виражені недоліки у загальній тактиці гри.
Крім того, ці класичні програми не отримали майже нічого від збільшення доступних обчислювальних потужностей і прогрес в цій області в цілому йшов дуже повільно.

Кілька дослідників зрозуміли потенціал імовірнісних методів і передбачили, що вони будуть домінувати у комп'ютерному Го. Але у той же час вони розуміли те, що гарну ігрову програму можна буде розробити тільки в далекому майбутньому, в результаті фундаментальних досягнень в загальній технології штучного інтелекту. Навіть написати програму, здатну автоматично визначати переможця готової грі не тривіальне завдання.

Поява програм, заснованих на пошуку Монте-Карло, кардинально змінила ситуацію, хоча розрив між професійними гравцями і найсильнішими програми все ще залишається значним.

\section{Існуючі рішення}
\subsection{Проблема подання}
Проблема, яку повинні вирішувати всі програми для гри в Го -- проблема подання поточного стану дошки. Програми, що використовують складні алгоритми пошуку, повинні мати можливість легко копіювати/подифікувати це подання для кожного наступного руху, що розглядається. Це додає складнощі до структури даних, в якій зберігається цей стан. Вона повинна будти доволі малою, щоб копіювання та подифікування її займало мало часу, але, у той же час, вона повинна бути гнучкою, бо вона повинна утримувати додаткову інформацію, що допоможе зробити сам алгоритм пошуку більш ефективним.

Найбільш очевидний спосіб подання дошки -- дво- або одновимірний массив кожний єлемент якого зберігає стан відповідної клітинки дошки -- зайнята чорним каменем, зайнята білим каменем, вільна. Також обов'язкова додаткова інформація, потрібна для зберігання -- скільки каменів полонив кожен з гравців, чий зараз хід і які ходи заборонені, через правило Ко.

(Перекласти)
Більшість програм , однак , використовувати не тільки інформацію сирої дошки для оцінки позиції . Дані наприклад , які камені , пов'язані в рядках , які рядки , пов'язаних один з одним , які групи каменів знаходяться в небезпеці захоплення і які групи каменів практично немає необхідні, щоб зробити точну оцінку позиції . Хоча ця інформація може бути залучена з усього кам'яних позицій , багато з яких можуть бути обчислені більш швидко , якщо вона оновлюється в додаткових , за - ходу основі. Це додатковий оновлення потрібно більше інформації, щоб бути збережені як стан плати , що в свою чергу може зробити копіювання рада зайняти більше часу. Цей вид компромісу свідчить про проблеми , що виникають в процесі швидкого комп'ютерні програми Go.

Альтернативним методом є мати єдину плату і зробити і забрати рухається таким чином , щоб звести до мінімуму вимоги до пам'яті комп'ютера і мати результати оцінки борту зберігається . Це дозволяє уникнути необхідності копіювати інформацію знову і знову.
\subsection{Філософія дизайну}
Єдиний вибір програма повинна зробити це, де розмістити свій наступний камінь. Проте, це рішення утруднюється широкого спектра дії одного каменя може мати по всій дошці, і групи складних взаємодій різних каменів »може мати один з одним. Різні архітектури виникли для вирішення цієї проблеми. Найпопулярніше використання: деякі форми пошуку по дереву, застосування методів Монте-Карло, застосування зіставлення із зразком, створення систем, заснованих на знаннях, і використання машинного навчання. Лише деякі програми використовувати тільки один з цих методів виключно; Найбільш комбінувати частини один в одному синтетичному системи.
\subsection{Оціночна функція}
У той час як простий оцінки підрахунку матеріал не є достатнім для гідного гри в шахи , часто основою функції оцінки шахи , коли в поєднанні з більш тонких міркувань , таких як ізольовані / здвоєних пішаків , лодії на відкритих файлів ( стовпців) , пішаки в центрі ради директорів і так далі. Ці правила можуть бути формалізовані легко , забезпечуючи досить хорошу функцію оцінки , яка може працювати швидко.

Ці типи позиційних правил оцінки не може ефективно застосовуватися для Go. Значення позиції До залежить від комплексного аналізу , щоб визначити , чи дійсно ця група живих , який камені можуть бути з'єднані один з одним , і евристика навколо тій мірі, в якій сильний вплив позиція , або ступінь , в якій слабкий положення може бути атакований .

Більше ніж один крок можна розглядати як кращий залежно від використовуваного стратегія . Для того щоб вибрати крок , комп'ютер повинен оцінити різні можливі результати і вирішити , що краще. Це важко через тонких компромісів , присутніх в Go. Наприклад , це може бути можливим , щоб захопити деякі ворожі камені за рахунок посилення камені супротивника в іншому місці. Чи може це хороша угода чи ні бути важким рішенням , навіть для гравців -людей. Обчислювальна складність і тут показує , як крок може бути не відразу важливі, але після багато ходів може стати дуже важливо , як інші області борту набувати форму.
\subsection{Мінімакс дерево пошуку}
Один з традиційних А.І. техніка для створення Пограти програмного забезпечення є використання мінімаксних дерево пошуку . Це включає в себе , граючи все гіпотетичні ходи на дошці до певної точки , то за допомогою функції оцінки оцінити значення цієї позиції для поточного гравця. Цей крок , який веде до кращої гіпотетичного ради обраний, і процес повторюється кожен хід . У той час як результати дерев були дуже ефективні в комп'ютерних шахах , вони бачили менший успіх в програмах Комп'ютер Go. Це почасти тому , що традиційно було важко створити ефективну функцію оцінки для Go борту , і почасти тому , що велика кількість можливих ходів кожна сторона може зробити кожен , призводить до високої розгалуження фактора. Це робить цей метод дуже великих обчислювальних витрат . Через це, багато програми , які використовують дерев пошуку широко можуть грати тільки на меншому 9x9 дошки , а не повних 19x19 з них.

Є кілька методів , які можуть значно поліпшити продуктивність дерев пошуку з точки зору швидкості і пам'яті. Методи Обрізка , такі як альфа- бета відсікання , основного варіанту Пошук і МПД - е також може істотно знизити коефіцієнта розгалуження без втрати міцності. У тактичних таких областях , як життя і смерть , Перейти Особливо піддаються методик кешування , таких як транспозиції таблиць . Вони можуть зменшити кількість повторних зусиль , особливо в поєднанні з ітеративний підхід поглиблення. Для того , щоб швидко зберегти повнорозмірну Перейти дошка в таблиці перестановок , техніка хешування для математично підбиття підсумків , як правило , необхідно. Зобріст хешування дуже популярний в програмах піти , тому що у нього є низькі ціни зіткнення , і може бути багато разів оновлюється при кожному русі за допомогою всього двох операцію XOR , а не розраховується з нуля. Навіть за допомогою цих методів підвищують працездатність , повні результати дерево на повнорозмірний борту все ще непомірно повільно. Пошук може бути прискорене за допомогою великої кількості конкретних методів доменних обрізки , таких як не розглядає кроки, коли ваш опонент вже сильний і вибіркових продовжень , як завжди , враховуючи рухається поруч з групами каменів , які ось-ось буде захоплений . Проте , обидві ці опції ввести в собі істотний ризик не рахуючи життєво хід , який би змінив хід гри.

Результати комп'ютерних змагань показують , що зіставлення із зразком методи вибору жменю відповідних кроків у поєднанні з швидко локалізованих тактичних пошуків ( див. вище) були колись достатньо для отримання конкурсну програму. Наприклад , GNU Go не було конкурентоспроможної до 2008 року.

\subsection{Системи, засновані на знаннях}
Новачки часто дізнатися багато з гри записів старих зіграних майстер гравців . Існує сильна гіпотеза , що говорить про те , що придбання Перейти знання є ключовим , щоб зробити сильний комп'ютер Go. Наприклад , Тім Kinger і Девід Mechner стверджують , що "ми вважаємо , що кращими засобами для представлення і підтримки Перейти знання , можна буде розвивати більш тісні програми Go" . Вони пропонують два шляхи: про визнання поширених конфігурацій каменів і їх позиції і зосередитися на місцевих битв. " ... Програми Go раніше не вистачає і в якості і кількості знань». [ 33 ]

Після реалізації , використання спеціальних знань було доведено , дуже ефективні в програмування Go програмного забезпечення. Сотні принципів і емпіричних правил для сильною грою були сформульовані як любителів , так і професіоналів високого рівня. Завдання програміста це взяти ці евристики , формалізувати їх у комп'ютерному коді , і використовувати зіставлення зі зразком і розпізнавання образів алгоритми визнати , коли ці правила застосовуються. Важливо також мати систему для визначення того , що робити в тому випадку , дві конфліктувати принципи застосовні .

Більшість щодо успішних результатів виходити від індивідуальних навичок програмістів на Go і їх особисті здогади про йти , але не від формальних математичних тверджень ; вони намагаються зробити комп'ютер імітувати , як вони грають Go. "Більшість конкурсні програми зажадали 5-15 людино- років зусиль , і містять 50-100 модулів , присвячених різним аспектам гри. " [ 34 ]

Цей метод до недавнього був найуспішнішим методом у генерації конкурентоспроможні програми піти на повнорозмірний борту. Деякі з прикладів програм , які значною мірою спиралися на експертних знаннях є Handtalk ( пізніше відомий як Goemate ) , Багатоликий Go , Go Інтелект і Go + + , кожна з яких в якийсь момент були розглянуті краща програма Go в світі.

Проте , додавши , знання Go іноді послаблює програму , тому що деякі поверхневі знання можуть принести помилки: . ». Кращі програми , як правило , грають хороші , рухається майстер рівня Однак , як кожен гри гравець знає , тільки один поганий хід може зіпсувати хорошу гру Виконання програми протягом повного грі може бути значно нижче , ніж майстер рівні ". [ 34 ]

\subsection{Методи Монте-Карло}
Одним з основних альтернативою використанню ручного кодування знання і пошуки є використання методів Монте -Карло. Це робиться шляхом створення списку потенційних ходів , і на кожен хід розігрується тисячі ігор випадковим чином на результаті борту. Цей крок , який веде до кращих набором випадкових ігор для поточного гравця вибирається в якості кращого ходу. Перевага цього методу полягає в тому , що він вимагає дуже мало знань в предметній області або експертний внесок , компроміс збільшується вимоги до пам'яті і процесора . Однак , так як рухається , використовувані для оцінки генерується випадковим чином , можливо , що крок , який би відмінно для одного конкретного відповіді суперника винятком буде помилково оцінюється як хороший хід. Результатом цього є програми , які сильні в загальний стратегічний сенс , але слабкі тактично . Ця проблема може бути пом'якшена , додавши деякі знання предметної області в генерації хід і більш високий рівень глибини пошуку в верхній частині випадкової еволюції. Деякі програми , які використовують методи Монте -Карло є Fuego , Багатоликий Go v12 , Ліла , MoGo , Божевільний камінь , MyGoFriend , і дзен .

У 2006 році нова техніка пошуку , верхні межі довірчих застосовується до дерев (УКТ ) , була розроблена і застосована до багатьох 9x9 Монте -Карло Go програм з відмінними результатами. UCT використовує результати плей аутів , зібраних до цих пір, щоб вести пошук вздовж найбільш успішних ліній гри , хоча і надає альтернативні лінії , які будуть вивчені. UCT техніка поряд з багатьма іншими оптимізаціями для гри на великому дошці 19х19 призвело MoGo стати одним з найсильніших дослідницьких програм . Успішні перші застосування методів UCT до 19х19 Go включають MoGo , Crazy Stone , і Mango. MoGo виграв 2007 Комп'ютерна олімпіада і виграв один ( з трьох) бліц гру проти Го Хуан , 5 -й Дан Pro , в набагато менш складним 9x9 Go . Багатоликий Go виграв 2008 Комп'ютерна олімпіада після додавання пошук UCT до своєї традиційної двигуна , заснованої на знаннях .

\subsection{Машинне навчання}
У той час як системи, засновані на знаннях були дуже ефективні в Go , їх рівень кваліфікації тісно пов'язана з відома їх програмістів і пов'язаних з ними експертам у цій галузі. Один із способів розірвати це обмеження є використання методів машинного навчання , з тим щоб програмне забезпечення для автоматичного створення правил , візерунки , та / або стратегії вирішення конфліктних правило .

Це зазвичай робиться , дозволяючи нейронна мережа або генетичний алгоритм або переглянути велику базу даних професійних ігор, або грати багато ігор проти себе чи інших людей або програм. Ці алгоритми потім в змозі використати ці дані як засіб підвищення ефективності їх роботи. Відомі програми, що використовують нейронні мережі є NeuroGo і WinHonte .

Методи машинного навчання також можуть бути використані в менш амбіційною контексті для настройки певних параметрів програм , які ґрунтуються головним чином на інші методи. Наприклад , Божевільний камінь вчиться рухатися моделей покоління від декількох сотень зразків ігор, використовуючи узагальнення системі рейтингу ЕЛО.

Правило формалізації проблеми в комп'ютерній комп'ютерних ігор [ ред] Коли два комп'ютери пограти в Go один проти одного , ідеал для лікування гру таким чином , ідентичною двох людей , що грають , уникаючи при цьому ніякого втручання від реальних людей. Тим не менш, це може бути важко під час кінця гри забив. Основна проблема полягає в тому , що Go грати програмне забезпечення , яке, як правило , зв'язується з використанням стандартної Text Protocol Go ( ГТФ ) , не завжди згодні стосовно живий чи мертвий статусу каменів.

Хоча ні загальний спосіб для двох різних програм , спрямованих на " виговоритися " і вирішити конфлікт , ця проблема усувається здебільшого за допомогою китайців , Tromp - Тейлор , або AGA правила , в яких продовжували грати (без штрафу) вимагається поки немає більш розбіжності про стан будь-яких каменів на дошці. На практиці , наприклад , на KGS Go Server , сервер може виступити посередником спору шляхом відправки спеціальної команди GTP до двох клієнтських програм із зазначенням вони повинні продовжувати розміщення каменів , поки не стоїть питання про статус тієї чи іншої групи ( всі мертві камені були захоплені в полон ) . CGOS Перейти Сервер зазвичай бачить програми відставку до гри навіть досягла фази забив , але проте підтримує модифіковану версію правил Тромп - Тейлора , що вимагають повною мірою грати поза .

Слід зазначити , що ці набори правил означає , що програма , яка була у виграшній позиції в кінці гри під японським правилами (коли обидва гравці пройшли ) може втратити через погану гру у фазі дозволу , але це не звичайним явищем і вважається нормальною частиною гри під всі набори правил площу.

Основний недолік зазначеної системи є те , що деякі набори правил ( наприклад , традиційних японських правил) карати гравців за прийняття цих додаткових ходів , виключаючи застосування додаткового перегону для двох комп'ютерів . Тим не менше, більшість сучасних Go Програми підтримки японських правила проти людей і компетентні як у грі і забив ( Fuego , Багатоликий Go , SmartGo і т.д.).

Історично склалося так , інший спосіб вирішення цієї проблеми в тому , щоб мати експертне людський судді остаточну плату. Однак це призводить до суб'єктивності в результатах і ризик того , що експерт буде не вистачати щось програма бачив.

\newpage
\section{Додаткова інформація}
\subsection{Бази}
Електронні бази даних може бути використаний для вивчення життя і смерті ситуацій , дзесекі , фусекі та ігри на конкретного гравця. Програми доступні дати гравцям шаблон пошуку варіантів , що дозволяє гравцеві досліджувати позиції шляхом пошуку високого рівня гри , в яких відбуваються подібні ситуації. Таке програмне забезпечення , як правило , перелік спільних слідувати до ходи, які були відтворені професіоналами , і дати статистику по співвідношенню перемог / втрат у відкритті ситуацій .

\subsection{Зобріст хешування}
Є будівництво хеш-функція використовується в комп'ютерних програмах, які грають абстрактні настільні ігри, такі як шахи і йдуть, для здійснення транспозиції столи, особливий вид хеш-таблиці, яка індексуються стані борту і використовується, щоб уникнути аналізу ту ж позицію більше одного разу. Зобріст хешуювання названий на честь його винахідника, Альберт Ліндсі Зобріст. [2] Це також застосовується як методу визнання заміщення конфігурацій сплаву при моделюванні кристалічних матеріалів.

Зобріст хеширования починається випадково виробляючи bitstrings для кожного можливого елемента настільної гри, тобто для кожної комбінації шматок і положенням (у грі в шахи, це 12 штук x64 позицій борту, або 14, якщо король, що може ще замок і пішак, які можуть захопити мимохідь розглядаються окремо). Тепер будь-якої конфігурації плата може бути розбитий на незалежні компоненти шт / положення, які, відображених на випадкових bitstrings генеруються раніше. Остаточний Зобріст хеш обчислюється через ці bitstrings використовуючи побітовое XOR. Приклад псевдокод для гри в шахи:
%constant indices white_pawn := 1 white_rook := 2 # etc. black_king := 12

%function init_zobrist(): # fill a table of random numbers/bitstrings table := a 2-d array of size 64x12 for i from 1 to 64: # loop over the board, represented as a linear array for j from 1 to 12: # loop over the pieces table[i][j] = random_bitstring()

%function hash(board): h := 0 for i from 1 to 64: # loop over the board positions if board[i] != empty: j := the piece at board[i], as listed in the constant indices, above h := h XOR table[i][j] return h ''

Якщо bitstrings досить довго , різні позиції дошка майже напевно хеш різним значенням ; Однак більш довгі bitstrings вимагають пропорційно більше ресурсів комп'ютера маніпулювати. Багато двигуни ігровому магазині тільки хеш- значення в таблиці перестановок , опускаючи саму інформацію про становище повністю для економії пам'яті , і припускаючи , що хеш зіткнення не відбудеться , або не буде в значній мірі вплинути на результати таблиці , якщо вони роблять.

Зобріст хешування є першим відомим екземпляром таблиць хешування . Результатом є 3 -мудрий незалежне сімейство хеш . Зокрема , це сильно універсальним.

Як приклад , у шахах , в кожному з 64 квадратів може в будь-який час бути порожнім , або містити одне з 6 частин гри , які або чорний або білий. Тобто , кожен квадрат може бути в одному з 1 + 6 х 2 = 13 можливих станів в будь-який час . Таким чином потрібно виробити не більше 13 х 64 = 832 випадкових bitstrings . Враховуючи положення , отримуємо його Зобріст хеш , з'ясувавши , які частини знаходяться на які квадратів , і комбінуючи відповідні bitstrings разом.

Замість того, щоб обчислення хеша на всій конференції кожен раз, як і вище псевдокод робить, значення хеш-функції дошки можуть бути оновлені, просто XORing поза бітову рядок (и) для позицій, які були змінені, і операції XOR в bitstrings для нового позиції. Наприклад, якщо пішак на шаховій дошці площі замінюється лодії з іншого площі, в результаті позиція буде проводиться XORing існуючий хеш з bitstrings для:

'pawn at this square' (XORing out the pawn at this square) 'rook at this square' (XORing in the rook at this square) 'rook at source square' (XORing out the rook at the source square) 'nothing at source square' (XORing in nothing at the source square).

Це робить Зобріст хешування дуже ефективним для обходу дерево гри. 

У комп'ютерній ходу, цей метод також використовується для виявлення Superko.

Той же метод був використаний визнати заміщення конфігурацій сплаву під час методу Монте-Карло, щоб запобігти витрачати обчислювальні витрати на держави, які вже були розраховані.
\subsection{Алгоритм Бенсона}
Не слід плутати з алгоритмом Бенсона, спосіб вирішення лінійних мульти-об'єктивні завдань оптимізації. У грі Го, алгоритм Бенсона (названий на честь Девіда Б. Бенсон) може бути використаний для визначення камені, які не є безпечними від захоплення не важливо, скільки поворотів поспіль противник отримує, тобто беззастережно живий.

Нехай X-множина всіх чорних ланцюгів і R безліч всіх чорних закритою регіонах X. Тоді алгоритм Бенсона вимагає ітеративного застосування наступні два кроки до ні на є можливість видалити будь-які додаткові ланцюга або регіони: 

Видалити з X все Чорні ланцюга з менше двох життєво важливих Чорного корпусі регіонів R, де чорний закритою область є життєво важливим для Чорного ланцюга в X, якщо всі його порожні перехрестя також свобод ланцюга. Видалити з R все Чорні закритою регіони з навколишнім каменем в ланцюзі не в X. Остаточний набір X є безліч всіх беззастережно живих чорних ланцюгів.
\section{Ігрове дерево}
Гра дерева важливі в галузі штучного інтелекту , тому що один із способів , щоб вибрати кращий хід у грі , щоб пошук по дерево гри з використанням алгоритму минимакса або його варіанти. Гра дерево хрестики- нулики легко проводити пошук , але повні ігри дерева для великих ігор , як шахи є занадто великими , щоб пошук . Замість цього , шахи -ігрова програма шукає часткове дерево гри : зазвичай так багато шарів з поточної позиції , як це може пошук в доступне час . Для випадку « патологічних » гри дерев винятком [ 1 ] (який, здається , досить рідко зустрічається в практиці) , збільшення глибини пошуку (тобто , кількість шарів шукали ) зазвичай підвищує ймовірність вибору кращого ходу.

Ігри двох осіб також можуть бути представлені як і - або дерева . Для першого гравця , щоб виграти гру , повинна існувати виграшний хід для всіх ходів другого гравця . Це представлено в і - або дерева за допомогою диз'юнкції представляти альтернативні ходи першого гравця і використовувати союз , щоб представляти всіх ходів другого гравця .
\subsection{Детермінований алгоритм}
Довільна гра дерево , яке було повністю кольоровий З повним дерева гри , можна "вирішити " гру - тобто сказати , знайти послідовність кроків , які або перший , або другий гравець може випливати, що гарантуватиме або виграш або краватку. Алгоритм (який зазвичай називають тому індукції або ретроградна аналіз) може бути описана рекурсивно таким чином.

Колір остаточний шар з дерева гри , так що всі виграші для гравця 1 пофарбовані в одну сторону ( синій на схемі) , всі виграші для гравця 2 , кольоровий інший спосіб (Red на схемі) , і всі зв'язки пофарбовані третій шлях ( сірий на схемі). Подивіться на наступний кордом вгору. Якщо існує вузол кольоровий навпроти якості поточного гравця , колір цей вузол для цього гравця , а також. Якщо все відразу нижні вузли пофарбовані для того ж гравця , колір цей вузол для того ж гравця , а також. В іншому випадку , колір цей вузол краватки. Повторіть ці дії для кожного шару , рухаючись вгору , поки всі вузли не пофарбовані. Колір кореневого вузла буде визначити характер гри. Діаграма показує дерево гри для довільної гри , кольорові використанням зазначеного вище алгоритму .

Як правило , можна вирішити гру ( в даному технічному сенсі " вирішити" ) , використовуючи тільки підмножина дерева гри , так як у багатьох іграх крок не повинен бути проаналізовані , якщо є інший хід , який краще для того ж гравця ( наприклад альфа- бета відсікання може використовуватися в багатьох детермінованих ігор).

Будь поддерево , які можуть бути використані для вирішення гру відомий як дерево рішень , і розміри дерев рішень різної форми використовуються в якості міри складності гри . [ 2 ]

\subsection{Рандомізоване Алгоритми}
Рандомізовані алгоритми можуть бути використані при вирішенні ігрових дерева. Є дві основні переваги в цьому типі реалізації: швидкість і практичність. У той час як детермінований варіант вирішення ігрових дерева можна зробити в O (п), наступне рандомізоване алгоритм має очікуваний час роботи teta (n0.792). Крім того, це практично, тому що рандомізовані алгоритми здатні "зриві ворога", що означає, що противник не може перемогти систему ігрових дерев, знаючи алгоритм, використовуваний для вирішення дерево гри, тому що порядок вирішення є випадковим. 

Нижче наведений здійснення рандомізованого ігровий дерева алгоритму рішення: [3]

%def gt_eval_rand(u): '''Returns true if this node evaluates to a win, otherwise false''' if u.leaf: return u.win elif u.op == 'OR': for child in random_order(u.children): if gt_eval_rand(child) == True: return True return False elif u.op == 'AND': for child in random_order(u.children): if gt_eval_rand(child) == False: return False return True'''

Алгоритм використовує ідеї "короткого замикання" - це означає, що, якщо кореневий вузол вважається "АБО" оператор, то, як тільки один "TRUE" знайдений, корінь класифікується як правда, і навпаки, якщо кореневий вузол вважається "І" оператор ніж один раз один "FALSE" знайдений, корінь класифікується як помилкове.