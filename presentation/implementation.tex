% \newpage
\chapter{Вибір засобів реалізації}
Темою даної дипломної робти є розробка системи для паралельного пошуку у структурах диних гри Го. Було реалізовано бібліотеку, що дозволяє шукати у структурах даних гри Го декількома різними способами. Ця бібліотеку може бути використана програмами, що аналізують партії в Го, збирають статистику з партій або ж шукають деякі закономірності у партіях. Щоб ця бібліотека була корисною і використовувалася, важливо вибрати правильну платформу та мову програмування для неї.

Основними властивостями розроблювальної бібліотеки повинні бути:
\begin{itemize}
	\item Платформонезалежність --- це зробить бібліотеку більш поширеною та зручною.
	\item Можливість використання у багатьох популярних мовах програмування (загалом, це доповнення до попереднього пункту).
	\item Простота реалізації. Бажано, щоб внутрішні структури даних, були змодельовані використовуючи вбудовані структури даних мови.
	\item Бажано, щоб мова підтримувала функціональний підхід програмування. Функціональний підхід гарно себе зарекомендував при роботі з штучним інтелектом або якимось складним аналізом даних.
\end{itemize}

Розглянемо деякі можливі платформи для поставленої задачі.
\section{Вибір платформи}
Вибір платформи для програми, це дуже важливе рішення, адже платформа одразу не тільки поставить обмеження на доступні мови програмування але і додасть свої плюси та мінуси, до розроблюваного програмного забезпечення. Загалом, дуже загально, можна разбити платформи на три пункти:
\begin{itemize}
	\item Без використання платформи
	\item .NET
	\item Java
\end{itemize}

Розглянемо їх по черзі оцінюючи доступні мови програмування для кожної платформи та їх плюси і мінуси.
\subsection{Без платформи}
Найочевиднішим вибором буде не використовувати ніяку платформу. Адже навіщо ускладнювати, якщо можна зробити простіше. Однак програмування, використовуючи платформу, таку як Java або .NET, має свої значні переваги. Однак при програмування бібліотеки методів пошуку, не обов'язково використовувати якусь платформу, тож розглянемо цей варіант.

Основними перевагами написання програми без використання будь-якої платформи є:
\begin{itemize}
	\item Відсутність прошарків між програмою та ОС (найчастіше)
	\item Не прив'язаність ні до яких інструментів
	\item Можливість написати простий standalone-додаток
\end{itemize}

Основними мовами, що розглядалися були:
\begin{itemize}
	\item C та C++
	\item Python
	\item Common Lisp
\end{itemize}

Мови \textbf{С} та \textbf{С++} загалом є не тільки мовами системного програмування. Їх з успіхом використовували для розробки різноманітних додатків. Основними перевагами цих мов є швидкодія отриманої програми. Недоліком є складність та витратність розробки програмного забезпечення, що працює зі складними структурами даних. Також не дуже зручно програмувати багатопоточність у програмах, якщо використовувати такі мови.

\textbf{Python} --- досить широко використовувана, скриптова, інтерпретована, високорівнева мова програмування. Вона доступна для більшості платформ. Вона підтримує концеп функціонального програмування, зокрема у ній функції є об'єктами першого класу (тобто можуть передаватися як змінна та будти збереженими у змінну). Також Python має багато вбудованих типів, що гарно підходять для данної задачі. Серед мінусів слід зазначити, що ця мова інтерпретована. Існування інтерпретатора накладає свої мінуси, серед яких зменшення швидкодії та залежність від додаткових програмних засобів.

\textbf{Common Lisp} --- це діалект Lisp-у, що набув значного розповсюдження у програмному світі. Існує реалізації під більшість платформ. Мова високорівнева, мультипарадигменна, компільована. Основні переваги для роботи з деревами ця мова має через те, що вона є Lisp-мовою, тобто вона створена для маніпулювання списками структура даних. У програмування дерева найчастіше подаються у вигляді списку списків, тому більшість алгоритмів для работи з деревами гарно програмуються на Lisp-і. Серед мінусів слід зазнасити невелику популярність (якщо порівнювати з іншими не-Lisp-ами), та невелику кількість бібліотек.

Загалом, серед розглянутого, Common Lisp був би найкращим вибором, якщо якость подолати його мінуси.
\subsection{JVM}
Віртуальна машина Java --- набір комп'ютерних програм та структур даних, що використовують модель віртуальної машини для виконання інших комп'ютерних програм чи скриптів. JVM використовує байт-код Java, який як правило, але не завжди генерується з вихідних кодів мови програмування Java; віртуальну машину також застосовують для виконання коду, згенерованого з інших мов програмування. JVM доступна для всіх основних сучасних платформ, тому про програми, що скомпільовані у Java байткод теоретично можна сказати ``Написано один раз, працює скрізь''.

Основними мовами для розглядання були:
\begin{itemize}
	\item Groovy
	\item Scala
	\item Clojure
\end{itemize}

\textbf{Groovy}
Groovy — об'єктно-орієнтована динамічна мова програмування, що працює в середовищі JRE. Мова Groovy запозичла деякі корисні якості Ruby, Haskell і Python, але створена для роботи всередині віртуальної машини Java (JVM) і підтримує тісну інтеграцію з Java програмами.

\textbf{Scala} --- мультипарадигмова мова програмування, що поєднує властивості об'єктно-орієнтованого та функційного програмування.

\textbf{Clojure} --— сучасний діалект мови програмування Lisp. Це мова загального призначення, що підтримує інтерактивну розробку, зорієнтовану на функціональне програмування, спрощує багатотредове програмування, та містить риси сучасних скриптових мов. Clojure працює на Java Virtual Machine і Common Language Runtime.

% Як і інші Lisp-подібні мови, Clojure розглядає код як дані і має потужну систему макросів. Clojure, бібліотеки и runtime-компоненти розповсюджується в рамках ліцензії Eclipse Public License. Clojure був розроблений з думкою про сучасний Lisp для функціонального програмування, розрахований на інтеграцію з розповсюдженою платформою Java й розроблений для паралельного програмування.

Підхід Clojure до паралельності характеризується концепцією тотожностей, що представляють серію незмінних станів протягом часу. Оскільки стани є незмінними значеннями, будь-яка кількість обробників може паралельно обробляти їх, і конкуренція зводиться до питання керування змінами від одного стану до іншого. З цією метою, Clojure надає декілька типів змінюваних посилань, кожен з яких має добре визначену семантику переходу між станами.
\subsection{.NET}
Microsoft .NET --- платформа від фірми Microsoft для створення як звичайних програм, так і веб-застосунків. Багато в чому є продовженням ідей та принципів, покладених в технологію Java. Одною з ідей .NET є сумісність служб, написаних різними мовами. Хоча ця можливість рекламується Microsoft як перевага .NET, платформа Java має таку саму можливість.

Основні мови, що розглядалися:
\begin{itemize}
	\item C\#
	\item C++/CLI
	\item F\#
\end{itemize}

\textbf{C\#} --— об'єктно-орієнтована мова програмування з безпечною системою типізації для платформи .NET. Розроблена Андерсом Гейлсбергом, Скотом Вілтамутом та Пітером Гольде під егідою Microsoft Research.

\textbf{C++/CLI} --— прив'язка мови програмування С++ до середовища програмування .NET фірми Microsoft. Вона інтегрує С++ стандарту ISO з Об'єднаною системою типів (Unified Type System, UTS), що розглядається як частина Загальної мовної інфраструктури (Common Language Infrastructure, CLI). Вона підтримує і сирцевий рівень, і функціональну сумісність виконуваних файлів, скомпільованих із рідного і керованого C++. C++/CLI являє собою еволюцію С++. C++/CLI стандартизований в ECMA як ECMA-372.

\textbf{F\#} --— багатопарадигмова мова програмування, розроблена в підрозділі Microsoft Research і призначена для виконання на платформі Microsoft.NET. Вона поєднує в собі виразність функціональних мов, таких як OCaml і Haskell, з можливостями і об'єктною моделлю .NET. Функційна мова максимально адаптована до використання в .NET Framework, відповідно, вона не заперечує і імперативного підходу.
\subsection{Висновки}
Написання бібліотеки без платформи хоч і має свої плюси, однак мінуси у вигляді втрати доступу до великої кількості розробників, що все використовують якусь платформу, важать більше, ніж плюси. До того ж більшість розглянутих мова не дуже підходить до задачі. Вийняток складає мова Common Lisp, що гарно підходить для програмування вибраних методів, однак її популярність ще менша.

Розглядаючи .NET, ми відмітили, що платформа сама по собі досить актуальна, але набір мов, що доступні для розробки на цій платформі, також не дуже підходить для розробки системи пошуку у структурах даних гри го.

У свою чергу Java демонструє багато позитивних сторін, що знадобляться для реалізації методів. Вона популярна, багатоплатформена, має значний набір мов програмування. Більшість з них досить своєрідні, однак Clojure --- гарний вибір для розробки бібліотеку.
\section{Вибір мови програмування}
\subsection{Grooby}
Groovy є більш високорівневою мовою програмування порівняно з Java, а отже розробка на ньому зазвичай відбувається швидше. Цьому сприяють перш за все динамічна природа мови, а по друге існуючі елементи функціонального програмування, зокрема замикання.

Функціональній спрямованості мови розробники надають один з найбільших пріоритетів. Нові можливості з'являються досить регулярно. Режим статичної компіляції для забезпечення підвищеної продуктивності для критичних до швидкості виконання ділянок коду
\subsection{Scala}
На Scala вплинуло багато мов. Однорідна об'єктна модель вперше з'явилася у Smalltalk і згодом у Ruby. Універсальність вкладеності присутня у Algol, Simula, Beta. Принцип однорідного доступу для виклику методу і звернення до поля походить з мови Eiffel. Підхід до функціонального програмування подібний до підходу родини мов ML, таких як has SML, OCaml і F\#. Багато функцій вищого порядку у стандартній бібліотеці Scala також наявні у ML або Haskell. Неявні параметри у Scala аналогічні класам типів Haskell. Заснована на акторах бібліотека багатозадачності подібна до Erlang.
\subsection{Clojure}
% Як і інші Lisp-подібні мови, синтаксис Clojure побудовано на S-виразах, які в процесі синтаксичного розбору спершу перетворюються на структури даних за допомогою функції-читача (reader), перш ніж компілюються. Clojure's reader підтримує літеральний синтаксис для хеш-таблиць, множин та векторів на додаток до списків, і вони передаються компілятору як є. Іншими словами, компілятор Clojure компілює не лише спискові структури даних, але й безпосередньо підтримує всі названі вище типи. Clojure — Lisp-1, і не є сумісним за кодом з іншими діалектами мови Lisp.

% Система макросів Clojure дуже схожа на використовувану в Common Lisp, з тією відмінністю, що версія синтаксичного цитування Clojure (з використанням знаку ` ) доповнює символи їхніми просторами імен. Це допомагає запобігти ненавмисному перехопленню імен, оскільки прив'язка до імен, доповнених простором імен, заборонена. Є можливість форсувати таке захоплення імен, але це має бути зроблено явно. Clojure також не дозволяє переприв'язку глобальних імен з інших просторів імен, які були імпортовані в поточний простір.

Clojure компільована мова, вона геренує байткод для  JVM. Вона має значну інтеграцію з Java: відкомпільовані в байткод JVM, програми на Clojure можуть пакуватися та запускатися на JVM-серверах без додаткових ускладнень. Мова також надає макроси, які полегшують використання існуючих Java API. Всі структури даних Clojure реалізують стандартні інтерфейси Java, що робить простим запуск з Java коду, розробленого на Clojure. Вона має мультиметоди (аналог перевантажень функцій), що підтримують динамічний вибір метода за типами та значеннями довільного набору аргументів.

% Серед основних відмінностей Clojure від інших Lispv-мов можна зазначити, що Clojure —-- Lisp-1, тобто для змінних та функцій використовується спільний простір імен — так само, як у Scheme, але не в Common Lisp. Всі глобальні змінні можна динамічно переприв'язувати без конфлікту з лексичними локальними прив'язками. Спеціальні оголошення для розрізнення динамічних та лексичних прив'язок — не потрібні.

Найбільша відмінність Clojure — послідовності. Це не якийсь окремий тип колекцій, особливо враховуючи, що їм необов'язково бути саме списками. При спробі отримати з порожньої колекції послідовність її елементів (викликом seq) повертається nil. При спробі отримати з послідовності (на її останньому елементі) залишок (rest) буде повернуто іншу логічну послідовність. Перевірити, чи ця послідовність порожня, можна шляхом виклику seq. Це дозволяє послідовностям та протоколу послідовностей бути лінивими.

% Деякі функції для роботи з послідовностями відповідають функціям зі Scheme та CL, що маніпулюють лише з парами/cons ('списками') і повертають сторожове значення ('() або nil), яке представляє 'порожній' список. Їх результат у Clojure відрізняється тим, що повертається не специфічна порожя колекція, а інша логічна послідовність. Частина функцій для роботи з послідовностями не мають відповідників у Scheme/CL і являють собою Haskell/ML-подібні функції. Деякі з них повертають нескінченні або обчислювані послідовності, де аналогія з конкретними структурами даних, такими як списки у Scheme/CL, в кращому випадку лише приблизна.
\subsection{Висновки}
Серед розглянутих мов найбільше до вирішення данної задачі підходить мова Clojure. Вона має прив'язку до Java, тому це гарний варіант для розроблювання бібліотеки. Також ця мова -- діалект Lisp-у, тобто вміє добре працювати з списками. Не слід забувати про гарну підтримку паралельного програмування, вона знадобиться, при розроблюванні данного ПЗ.
